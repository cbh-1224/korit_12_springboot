# 입실 체크 해주세요 !! 🎈

# 금일 수업 계획
1. Spring Data REST 적용으로 인해 커스텀 Controller 및 Service를 매우 제한적으로 사용.
  - LoginController / JwtService
  - 그래서 Spring Data REST 의존성 삭제 후 Controller - Service - Repository로 이어지는 흐름을 Todo List로 확인할 예정
  - 이상의 흐름 동안에 필요한 개념이 DTO
  - 제한적으로 저희는 AccountCredentials record에서 확인을 했었습니다.
2. SpringBoot 프로젝트에서의 Google 로그인 기능(OAuth2)

# SpringBoot 3-Tier Architecture
- SpringBoot 프로젝트 상에서 애플리케이션의 유지보수성과 확장성을 높이기 위해 역할을 **분리**하는 표준적인 설계 방식으로 각 계층은 고유한 책임을 가지며, 이 계층 사이를 이동할 때 DTO(Data Transfer Object)를 통하게 됩니다.

만약에 Entity class User에 id/username/password/name/address라고 하는 field들이 있다고 가정하겠습니다. postman을 통해서 /login 엔드포인트를 통해 `{"username":"user", "password":"password"}`가 전송됐다고 했을 때, 이는 Controller를 통해 들어오게 되고 이를 Repository에서 확인하게 될겁니다. 그래서 UserRepository의 findByUsername(String username)을 호출해서 특정 User 객체가 return 될겁니다. 그것이 Controller를 통해서 postman의 응답창에 출력될거구요.

## 종류
1. Controller(Presentation Layer) : 클라이언트의 요청(HTTP Request)을 가장 먼저 받는 관문 역할입니다(어제 수업했습니다). 요청 데이터를 검증하고, 비지니스 로직을 수행하기 위해 서비스 계층을 호출하며, 최종 결과를 응답(HTTP Response)으로 반환합니다(그래서 return 타입이 ResponseEntity<?>였습니다).
2. Service(Business Logic Layer) : 애플리케이션의 핵심 비지니스 로직이 수행되는 곳입니다. 데이터의 가공, 트랜잭션 관리, 엔티티와 DTO 간의 변환 등을 담당합니다.
3. Repository(Data Access Layer) : 데이터베이스에 직접 접근하는 계층입니다. JPA를 사용했으니까 Entity 객체를 DB 테이블과 매핑하고, 실제 SQL을 실행하여 데이터를 처리합니다.
- 이상을 고려했을 때 postman에서 요청이 들어오면 Controller에서 요청을 검증하고 -> Service 계층으로 넘겨서 특정 정보가 있는지 여부를 체크하고 -> Repository에서 가져온 다음에 -> Service 계층에서 혹시 null값이 있는지, 아니면 정보 조합이 되는지 여부를 따진 다음에 -> Controller로 보내서 올바르다면 postman에 제대로 띄울 것이고, 아니면 Error메시지를 띄울겁니다.
- postman->controller->service->repository->db(여기까지요청부분)->service->controller(여기가응답객체리턴부분)->postman

4. DTO(Data Transfer Object)
- 계층 간 데이터 이동 시 데이터베이스 엔티티(예를 들면 Car, Owner, AppUser)를 직접 노출하지 않고 DTO를 사용합니다.
    - 보안 : 클라이언트에게 민감한 정보(password 등)가 노출되는 것을 방지.
    - 결합도 ↓ : DB 구조가 변경되어 엔티티가 수정되더라도 API 스펙(DTO)은 유지할 수 있습니다.
    - 유효성 검사 : 클라이언트가 보내는 데이터에 대해 특정 계층에서만 필요한 검증 로직을 추가하기에 용이.
  - 그래서 DTO의 경우 request 버전과 response 버전이 나뉘는 경우가 있습니다. 보낼때는 username/password만 있지만 돌아올 때는 username/password/todos 혹은 cars 등이 있을 수 있으니까요.

## 3-Tier Architecture 구현(TodoList 기준)
1. build.gradle에서 spring-data-rest를 삭제합니다.
2. 루트 패키지 내에 dto, repository, entity, service 패키지를 생성합니다.
3. 기존의 domain 내에 있던 .java 파일들을 각각 repository와 entity로 분할하겠습니다.

4. dto 패키지 내에 TodoRequest / TodoResponse를 만들었습니다. record로 만든 이유는 불변 객체를 생성하기 위해서 이고, Java14 이후 버전부터는 class로 만들기보다 record로 만들 것이 권장됩니다.
```java
package com.todo.todolist.dto;

public record TodoRequest(String content) {}

package com.todo.todolist.dto;

public record TodoResponse(Long id, String content, boolean isCompleted) {}
```

5. service 패키지 내에 TodoService를 생성하세요.
```java
package com.todo.todolist.service;

import com.todo.todolist.dto.TodoRequest;
import com.todo.todolist.dto.TodoResponse;
import com.todo.todolist.entity.Todo;
import com.todo.todolist.entity.User;
import com.todo.todolist.repository.TodoRepository;
import com.todo.todolist.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class TodoService {
    private final TodoRepository todoRepository;
    private final UserRepository userRepository;

    // POST 요청을 하는 비지니스 로직 작성
    @Transactional
    public TodoResponse createTodo(Long userId, TodoRequest request) {
        User user = userRepository.findById(userId).orElseThrow(() -> new RuntimeException("사용자를 찾을 수 없습니다."));

        // DTO -> Entity로의 변환
        Todo todo = new Todo(request.content(), user);  // Todo 객체 만들어지면 isCompleted=false가 적용됩니다.
        Todo savedTodo = todoRepository.save(todo);

        // Entity -> DTO로 변환해서 Controller로 넘겨줄겁니다.
        return new TodoResponse(savedTodo.getId(), savedTodo.getContent(), savedTodo.isCompleted());
    }

    // GET 요청을 하는 비지니스 로직 작성
    @Transactional(readOnly = true)
    public List<TodoResponse> getTodoList() {
        return todoRepository.findAll().stream()
                .map(todo -> new TodoResponse(todo.getId(), todo.getContent(), todo.isCompleted()))
                .collect(Collectors.toList());
    }
}
```

- 이상의 코드에서 다양한 repository를 field로 삼아서 메서드들을 호출한 다음, 필요한 정보들을 가공해서 TodoResponse 객체로 return했다는 점을 확인할 수 있습니다. 그 내부 로직 중에 제어문의 다수가 쓰였다는 점, Lambda expression이 쓰이고 있다는 점에서 이전 Java에서의 배경지식이 요구된다는 것도 확인할 수 있습니다. 그리고 .map() 꼭 복습하겠습니다.

6. controller 패키지에 todoController 생성하겠습니다.